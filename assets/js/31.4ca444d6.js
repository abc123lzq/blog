(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{390:function(t,s,a){"use strict";a.r(s);var v=a(42),r=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器工作原理"}},[t._v("#")]),t._v(" 浏览器工作原理")]),t._v(" "),a("h2",{attrs:{id:"多进程浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多进程浏览器"}},[t._v("#")]),t._v(" 多进程浏览器")]),t._v(" "),a("h3",{attrs:{id:"进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[t._v("#")]),t._v(" 进程与线程")]),t._v(" "),a("p",[t._v("线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15961770642275.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("进程中的任意一线程执行出错，都会导致整个进程的崩溃")]),t._v(" "),a("h3",{attrs:{id:"线程之间共享进程中的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程之间共享进程中的数据"}},[t._v("#")]),t._v(" 线程之间共享进程中的数据")]),t._v(" "),a("p",[t._v("线程之间可以对进程的公共数据进行读写操作。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15961772345039.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("h3",{attrs:{id:"进程关闭会回收进程所占用的内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程关闭会回收进程所占用的内存"}},[t._v("#")]),t._v(" 进程关闭会回收进程所占用的内存")]),t._v(" "),a("p",[t._v("IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，\n这意味着只要浏览器开着，内存占用就有可能会越来越多，\n但是当关闭浏览器进程时，这些内存就都会被系统回收掉。")]),t._v(" "),a("h3",{attrs:{id:"进程之间的内容相互隔离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程之间的内容相互隔离"}},[t._v("#")]),t._v(" 进程之间的内容相互隔离")]),t._v(" "),a("p",[t._v("每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。\n所以一个进程如果崩溃了，是不会影响到其他进程的。\n如果进程之间需要进行数据的通信，就需要使用用于进程间通信（IPC）的机制了。")]),t._v(" "),a("h3",{attrs:{id:"单进程浏览器时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单进程浏览器时代"}},[t._v("#")]),t._v(" 单进程浏览器时代")]),t._v(" "),a("p",[t._v("2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15961776281910.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。")]),t._v(" "),a("p",[a("strong",[t._v("不稳定")])]),t._v(" "),a("p",[t._v("早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，一个插件的意外崩溃会引起整个浏览器的崩溃。")]),t._v(" "),a("p",[t._v("渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。")]),t._v(" "),a("p",[a("strong",[t._v("不流畅")])]),t._v(" "),a("p",[t._v("所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。")]),t._v(" "),a("p",[a("strong",[t._v("不安全")])]),t._v(" "),a("p",[t._v("插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，\n当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。\n如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。")]),t._v(" "),a("p",[t._v("页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。")]),t._v(" "),a("h3",{attrs:{id:"多进程浏览器时代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多进程浏览器时代"}},[t._v("#")]),t._v(" 多进程浏览器时代")]),t._v(" "),a("p",[a("strong",[t._v("1.早期多进程架构")])]),t._v(" "),a("p",[t._v("2008 年 Chrome 发布时的进程架构。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15961783457086.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信")]),t._v(" "),a("p",[a("strong",[t._v("解决不稳定的问题")])]),t._v(" "),a("p",[t._v("由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面。")]),t._v(" "),a("p",[a("strong",[t._v("解决不流畅的问题")])]),t._v(" "),a("p",[t._v("JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面。")]),t._v(" "),a("p",[t._v("对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收。")]),t._v(" "),a("p",[a("strong",[t._v("解决不安全的问题")])]),t._v(" "),a("p",[t._v("采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁。")]),t._v(" "),a("p",[t._v("沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，")]),t._v(" "),a("p",[t._v("例如：你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。")]),t._v(" "),a("p",[a("strong",[t._v("2.目前多进程架构")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15961792435408.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、 "),a("code",[t._v("多个渲染进程和多个插件进程")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("浏览器进程")])]),t._v(" "),a("p",[t._v("主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")]),t._v(" "),a("p",[a("strong",[t._v("GPU 进程")])]),t._v(" "),a("p",[t._v("其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。")]),t._v(" "),a("p",[a("strong",[t._v("网络进程")])]),t._v(" "),a("p",[t._v("主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")]),t._v(" "),a("p",[a("strong",[t._v("渲染进程")])]),t._v(" "),a("p",[t._v("核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")]),t._v(" "),a("p",[a("strong",[t._v("插件进程")])]),t._v(" "),a("p",[t._v("主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")]),t._v(" "),a("p",[a("strong",[t._v("缺点：")])]),t._v(" "),a("p",[a("strong",[t._v("更高的资源占用")])]),t._v(" "),a("p",[t._v("因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。")]),t._v(" "),a("p",[a("strong",[t._v("更复杂的体系架构")])]),t._v(" "),a("p",[t._v("浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。")]),t._v(" "),a("h3",{attrs:{id:"未来面向服务的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未来面向服务的架构"}},[t._v("#")]),t._v(" 未来面向服务的架构")]),t._v(" "),a("p",[t._v("为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。")]),t._v(" "),a("p",[t._v("Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/1596180074705.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，\n但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/1596180188892.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("h2",{attrs:{id:"tcp协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议"}},[t._v("#")]),t._v(" TCP协议")]),t._v(" "),a("p",[t._v("在衡量 Web 页面性能的时候有一个重要的指标叫“FP（First Paint）”，是指从页面加载到首次开始绘制的时长。\n这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。")]),t._v(" "),a("p",[t._v("不管你是使用 HTTP，还是使用 WebSocket，它们都是基于 TCP/IP 的，\n如果你对这些原理有足够了解，也就清楚如何去优化 Web 性能，或者能更轻松地定位 Web 问题了。")]),t._v(" "),a("h3",{attrs:{id:"_1-ip-把数据包送达目的主机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-ip-把数据包送达目的主机"}},[t._v("#")]),t._v(" 1. IP：把数据包送达目的主机")]),t._v(" "),a("p",[t._v("计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。")]),t._v(" "),a("h3",{attrs:{id:"_2-udp-把数据包送达应用程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-udp-把数据包送达应用程序"}},[t._v("#")]),t._v(" 2.UDP：把数据包送达应用程序")]),t._v(" "),a("p",[t._v("IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序\n，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。")]),t._v(" "),a("p",[t._v("UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号")]),t._v(" "),a("p",[t._v("UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等")]),t._v(" "),a("h3",{attrs:{id:"_3-tcp-把数据完整地送达应用程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp-把数据完整地送达应用程序"}},[t._v("#")]),t._v(" 3. TCP：把数据完整地送达应用程序")]),t._v(" "),a("p",[t._v("TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议")]),t._v(" "),a("p",[t._v("对于数据包丢失的情况，TCP 提供重传机制；")]),t._v(" "),a("p",[t._v("和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。")]),t._v(" "),a("blockquote",[a("p",[t._v("一个完整的 TCP 连接，就是三次握手，四次挥手了 "),a("RouterLink",{attrs:{to:"/docs/ground/"}},[t._v("查看")])],1)]),t._v(" "),a("h2",{attrs:{id:"http-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-请求"}},[t._v("#")]),t._v(" HTTP 请求")]),t._v(" "),a("h3",{attrs:{id:"浏览器端发起"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器端发起"}},[t._v("#")]),t._v(" 浏览器端发起")]),t._v(" "),a("p",[a("strong",[t._v("1. 构建请求")])]),t._v(" "),a("p",[t._v("首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求")]),t._v(" "),a("div",{staticClass:"language-md extra-class"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[t._v("GET /index.html HTTP1.1\n")])])]),a("p",[a("strong",[t._v("2. 查找缓存")])]),t._v(" "),a("p",[t._v("在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。\n其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。")]),t._v(" "),a("p",[t._v("当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。")]),t._v(" "),a("p",[t._v("这样做的好处有：缓解服务器端压力，提升性能（获取资源的耗时更短了）；对于网站来说，缓存是实现快速资源加载的重要组成部分。\n当然，如果缓存查找失败，就会进入网络请求过程了。")]),t._v(" "),a("p",[a("strong",[t._v("3. 准备 IP 地址和端口")])]),t._v(" "),a("p",[t._v("先看看 HTTP 和 TCP 的关系。因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，\n所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965080198073.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，\n那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。")]),t._v(" "),a("p",[t._v("拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 "),a("code",[t._v("80")]),t._v(" 端口。")]),t._v(" "),a("p",[a("strong",[t._v("4. 等待 TCP 队列")])]),t._v(" "),a("p",[t._v("Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，\n如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。")]),t._v(" "),a("p",[t._v("如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。")]),t._v(" "),a("p",[a("strong",[t._v("5. 建立 TCP 连接")])]),t._v(" "),a("p",[t._v("排队等待结束之后，浏览器通过 TCP 与服务器建立连接")]),t._v(" "),a("p",[a("strong",[t._v("6. 发送 HTTP 请求")])]),t._v(" "),a("p",[t._v("一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。")]),t._v(" "),a("h3",{attrs:{id:"服务器端处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器端处理"}},[t._v("#")]),t._v(" 服务器端处理")]),t._v(" "),a("p",[a("strong",[t._v("1. 返回请求")])]),t._v(" "),a("p",[t._v("一旦服务器处理结束，便可以返回数据给浏览器了。")]),t._v(" "),a("p",[t._v("首先服务器会返回响应行，包括协议版本和状态码。\n一些无法被服务器处理的出错的信息，服务器会通过请求行的状态码来告诉浏览器它的处理结果，\n比如：最常用的状态码是 200，表示处理成功；如果没有找到页面，则会返回 404。")]),t._v(" "),a("p",[t._v("正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。\n响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），\n以及服务器要在客户端保存的 Cookie 等信息。")]),t._v(" "),a("p",[t._v("发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容或者json数据。")]),t._v(" "),a("p",[a("strong",[t._v("2. 断开连接")])]),t._v(" "),a("p",[t._v("通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：")]),t._v(" "),a("div",{staticClass:"language-md extra-class"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[t._v("Connection:Keep-Alive \n")])])]),a("p",[t._v("那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。\n保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。")]),t._v(" "),a("p",[t._v("比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。")]),t._v(" "),a("p",[a("strong",[t._v("3. 重定向")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965096294716.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。")]),t._v(" "),a("h3",{attrs:{id:"第二次打开速度会很快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二次打开速度会很快"}},[t._v("#")]),t._v(" 第二次打开速度会很快?")]),t._v(" "),a("p",[t._v("主要原因是第一次加载页面过程中，缓存了一些耗时的数据")]),t._v(" "),a("p",[t._v("哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。")]),t._v(" "),a("p",[t._v("其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965103224958.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。 如上图设置的缓存过期时间是 2000 秒。")]),t._v(" "),a("div",{staticClass:"language-md extra-class"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[t._v("Cache-Control:Max-age=2000\n")])])]),a("p",[t._v("如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：")]),t._v(" "),a("div",{staticClass:"language-md extra-class"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[t._v('If-None-Match:"4f80f-13c-3a1xb12a"\n')])])]),a("p",[t._v("服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。")]),t._v(" "),a("p",[t._v("如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”")]),t._v(" "),a("p",[t._v("如果资源有更新，服务器就直接返回最新资源给浏览器。")]),t._v(" "),a("h3",{attrs:{id:"登录状态是如何保持的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#登录状态是如何保持的"}},[t._v("#")]),t._v(" 登录状态是如何保持的？")]),t._v(" "),a("p",[t._v("如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。")]),t._v(" "),a("p",[t._v("当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。")]),t._v(" "),a("p",[t._v("服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。")]),t._v(" "),a("h2",{attrs:{id:"从输入url到页面展示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面展示"}},[t._v("#")]),t._v(" 从输入URL到页面展示")]),t._v(" "),a("h3",{attrs:{id:"流程解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程解析"}},[t._v("#")]),t._v(" 流程解析")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965109583453.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("ul",[a("li",[a("p",[t._v("首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。")])]),t._v(" "),a("li",[a("p",[t._v("然后，在网络进程中发起真正的 URL 请求。")])]),t._v(" "),a("li",[a("p",[t._v("接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。")])]),t._v(" "),a("li",[a("p",[t._v("浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；")])]),t._v(" "),a("li",[a("p",[t._v("渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；")])]),t._v(" "),a("li",[a("p",[t._v("最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。")])]),t._v(" "),a("li",[a("p",[t._v("浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。")])])]),t._v(" "),a("h3",{attrs:{id:"导航"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#导航"}},[t._v("#")]),t._v(" 导航")]),t._v(" "),a("blockquote",[a("p",[t._v("用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。")])]),t._v(" "),a("p",[a("strong",[t._v("1. 用户输入")])]),t._v(" "),a("p",[t._v("当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。\n如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。\n如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL")]),t._v(" "),a("p",[t._v("浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，\n比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。\n当前页面没有监听 beforeunload 事件或者同意了继续后续流程")]),t._v(" "),a("p",[t._v("当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。")]),t._v(" "),a("p",[a("strong",[t._v("2. URL 请求过程")])]),t._v(" "),a("p",[t._v("浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程。")]),t._v(" "),a("p",[t._v("首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。\n这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。")]),t._v(" "),a("p",[t._v("（1）重定向")]),t._v(" "),a("p",[t._v("果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。")]),t._v(" "),a("p",[t._v("（2）响应数据类型处理")]),t._v(" "),a("p",[t._v("不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。")]),t._v(" "),a("p",[a("strong",[t._v("3. 准备渲染进程")])]),t._v(" "),a("p",[t._v("Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。")]),t._v(" "),a("p",[t._v("在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中")]),t._v(" "),a("p",[t._v("我们将“同一站点”定义为根域名（例如，lzq.org）加上协议（例如，https:// 或者 http://），\n还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：")]),t._v(" "),a("div",{staticClass:"language-md extra-class"},[a("pre",{pre:!0,attrs:{class:"language-md"}},[a("code",[t._v("https://time.lzq.org\nhttps://www.lzq.org\nhttps://www.lzq.org:8080\n")])])]),a("p",[t._v("它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 lzq.org。")]),t._v(" "),a("p",[t._v("Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。\n官方把这个默认策略叫 process-per-site-instance。")]),t._v(" "),a("p",[t._v("渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。")]),t._v(" "),a("p",[a("strong",[t._v("4. 提交文档")])]),t._v(" "),a("p",[t._v("所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息")])]),t._v(" "),a("li",[a("p",[t._v("渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”")])]),t._v(" "),a("li",[a("p",[t._v("等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程")])]),t._v(" "),a("li",[a("p",[t._v("浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。")])])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965213291830.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[a("strong",[t._v("5. 渲染阶段")])]),t._v(" "),a("p",[t._v("一旦文档被提交，渲染进程便开始页面解析和子资源加载了，\n页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。")]),t._v(" "),a("h2",{attrs:{id:"渲染流程上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程上"}},[t._v("#")]),t._v(" 渲染流程上")]),t._v(" "),a("p",[t._v("导航被提交后,就进入了渲染阶段。这个阶段很重要。了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，\n比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，\n通过优化样式表来防止强制同步布局，等等。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965236968086.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。")]),t._v(" "),a("p",[t._v("输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/1596523802543.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。")]),t._v(" "),a("h3",{attrs:{id:"构建-dom-树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树"}},[t._v("#")]),t._v(" 构建 DOM 树")]),t._v(" "),a("p",[t._v("这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965241782019.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("其中每个点我们称为节点，相连的节点称为父子节点。渲染流程，就在频繁地使用树结构。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965243282598.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("要让 DOM 节点拥有正确的样式，这就需要样式计算了。")]),t._v(" "),a("h3",{attrs:{id:"样式计算-recalculate-style"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#样式计算-recalculate-style"}},[t._v("#")]),t._v(" 样式计算（Recalculate Style）")]),t._v(" "),a("p",[t._v("样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式")]),t._v(" "),a("p",[a("strong",[t._v("1. 把 CSS 转换为浏览器能够理解的结构")])]),t._v(" "),a("p",[t._v("那 CSS 样式的来源主要有哪些呢")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965245709670.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，\n所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。")]),t._v(" "),a("p",[t._v("你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965254686367.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[a("strong",[t._v("2. 转换样式表中的属性值，使其标准化")])]),t._v(" "),a("p",[t._v("现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2em "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("blue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" none"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div  p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("green"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，\n这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965259762601.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……")]),t._v(" "),a("p",[a("strong",[t._v("3. 计算出 DOM 树中每个节点的具体样式")])]),t._v(" "),a("p",[t._v("涉及到 CSS 的继承规则和层叠规则了")]),t._v(" "),a("p",[t._v("CSS 继承就是每个 DOM 节点都包含有父节点的样式。")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 20px "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("blue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" none"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div  p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("green"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("img",{attrs:{src:t.$withBase("/js/browser/15965261529910.png?v=1"),width:"800",alt:"img"}}),t._v("\n所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。\n"),a("p",[t._v("打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965262546625.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965263684236.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("h3",{attrs:{id:"布局阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布局阶段"}},[t._v("#")]),t._v(" 布局阶段")]),t._v(" "),a("p",[t._v("现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。")]),t._v(" "),a("p",[t._v("计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。")]),t._v(" "),a("p",[a("strong",[t._v("1. 创建布局树")])]),t._v(" "),a("p",[t._v("DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。")]),t._v(" "),a("p",[t._v("所以在显示之前，我们还要"),a("code",[t._v("额外地构建一棵只包含可见元素布局树")]),t._v("。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965265748241.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。")]),t._v(" "),a("p",[t._v("为了构建布局树，浏览器大体上完成了下面这些工作：")]),t._v(" "),a("ul",[a("li",[t._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；")]),t._v(" "),a("li",[t._v("而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。")])]),t._v(" "),a("p",[a("strong",[t._v("2. 布局计算")])]),t._v(" "),a("p",[t._v("现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。")]),t._v(" "),a("p",[t._v("在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，")]),t._v(" "),a("p",[t._v("因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。")]),t._v(" "),a("p",[t._v("针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。")]),t._v(" "),a("h2",{attrs:{id:"渲染流程下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程下"}},[t._v("#")]),t._v(" 渲染流程下")]),t._v(" "),a("h3",{attrs:{id:"分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[t._v("#")]),t._v(" 分层")]),t._v(" "),a("p",[t._v("因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，\n为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。")]),t._v(" "),a("p",[t._v("渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/1596528526936.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，\n那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("需要满足什么条件，渲染引擎才会为特定的节点创建新的图层")])]),t._v(" "),a("p",[a("strong",[t._v("第一点，拥有层叠上下文属性的元素会被提升为单独的一层。")])]),t._v(" "),a("p",[t._v("页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。\n你可以结合下图来直观感受下：")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965288751296.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context",target:"_blank",rel:"noopener noreferrer"}},[t._v("更多层叠上下文的知识"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("strong",[t._v("第二点，需要剪裁（clip）的地方也会被创建为图层。")])]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token style"}},[a("span",{pre:!0,attrs:{class:"token language-css"}},[t._v("\n      "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("width")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 200"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("height")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 200"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("overflow")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("auto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("background")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" gray"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图："),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("div设置了溢出隐藏 ，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。")]),t._v(" "),a("p",[t._v("文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965292277923.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。")]),t._v(" "),a("h3",{attrs:{id:"图层绘制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[t._v("#")]),t._v(" 图层绘制")]),t._v(" "),a("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制")]),t._v(" "),a("p",[t._v("把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/1596529792212.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。\n而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。")]),t._v(" "),a("p",[t._v("你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965299316881.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。")]),t._v(" "),a("h3",{attrs:{id:"栅格化-raster-操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栅格化-raster-操作"}},[t._v("#")]),t._v(" 栅格化（raster）操作")]),t._v(" "),a("p",[t._v("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965301331322.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？")]),t._v(" "),a("p",[a("strong",[t._v("屏幕上可见区域就叫视口")])]),t._v(" "),a("p",[t._v("在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，\n所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。")]),t._v(" "),a("p",[t._v("基于这个原因，"),a("code",[t._v("合成线程会将图层划分为图块（tile）")]),t._v("，这些图块的大小通常是 256x256 或者 512x512，如下图所示：")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/1596530603444.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。")]),t._v(" "),a("p",[t._v("所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965310124672.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。")]),t._v(" "),a("p",[t._v("相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965311979376.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。")]),t._v(" "),a("h3",{attrs:{id:"合成和显示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[t._v("#")]),t._v(" 合成和显示")]),t._v(" "),a("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),t._v(" "),a("p",[t._v("浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，\n将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),t._v(" "),a("p",[t._v("到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。")]),t._v(" "),a("h3",{attrs:{id:"渲染流水线大总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染流水线大总结"}},[t._v("#")]),t._v(" 渲染流水线大总结")]),t._v(" "),a("p",[t._v("我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965313738935.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("结合上图，一个完整的渲染流程大致可总结为如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")])]),t._v(" "),a("li",[a("p",[t._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。")])]),t._v(" "),a("li",[a("p",[t._v("创建布局树，并计算元素的布局信息。")])]),t._v(" "),a("li",[a("p",[t._v("对布局树进行分层，并生成分层树。")])]),t._v(" "),a("li",[a("p",[t._v("为每个图层生成绘制列表，并将其提交到合成线程。")])]),t._v(" "),a("li",[a("p",[t._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")])]),t._v(" "),a("li",[a("p",[t._v("合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")])]),t._v(" "),a("li",[a("p",[t._v("浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。")])])]),t._v(" "),a("h3",{attrs:{id:"相关概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[t._v("#")]),t._v(" 相关概念")]),t._v(" "),a("p",[t._v("有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念—— "),a("code",[t._v("重排、重绘、合成")])]),t._v(" "),a("p",[a("strong",[t._v("1. 更新了元素的几何属性（重排）")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965316888835.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，\n解析之后的一系列子阶段，这个过程就叫重排。无疑，"),a("code",[t._v("重排需要更新完整的渲染流水线，所以开销也是最大的")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("2. 更新元素的绘制属性（重绘）")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965318458766.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，\n然后执行之后的一系列子阶段，这个过程就叫重绘。\n相较于重排操作，"),a("code",[t._v("重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些")])]),t._v(" "),a("p",[a("strong",[t._v("3. 直接合成阶段")])]),t._v(" "),a("p",[t._v("那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/js/browser/15965319917263.png?v=1"),width:"800",alt:"img"}}),t._v(" "),a("p",[t._v("我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，\n因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，"),a("code",[t._v("所以相对于重绘和重排，合成能大大提升绘制效率。")])]),t._v(" "),a("Utterances")],1)}),[],!1,null,null,null);s.default=r.exports}}]);