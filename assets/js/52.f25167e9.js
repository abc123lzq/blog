(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{420:function(t,a,s){"use strict";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"并发编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[t._v("#")]),t._v(" 并发编程")]),t._v(" "),s("p",[t._v("高并发时候，开启多线程来提高处理性能，但多线程操作执行的方法里有很多是用同一个内存，这样会导致 计算不准确等问题。")]),t._v(" "),s("h2",{attrs:{id:"悲观锁与乐观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁与乐观锁"}},[t._v("#")]),t._v(" 悲观锁与乐观锁")]),t._v(" "),s("h3",{attrs:{id:"悲观锁-多写场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁-多写场景"}},[t._v("#")]),t._v(" 悲观锁 （多写场景)")]),t._v(" "),s("ul",[s("li",[t._v("总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。")])]),t._v(" "),s("h3",{attrs:{id:"乐观锁-多读场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁-多读场景"}},[t._v("#")]),t._v(" 乐观锁（多读场景)")]),t._v(" "),s("ul",[s("li",[t._v("是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。")])]),t._v(" "),s("h2",{attrs:{id:"乐观常锁实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#乐观常锁实现"}},[t._v("#")]),t._v(" 乐观常锁实现")]),t._v(" "),s("ul",[s("li",[t._v("乐观锁一般会使用版本号机制或CAS算法实现。")])]),t._v(" "),s("h3",{attrs:{id:"版本号机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#版本号机制"}},[t._v("#")]),t._v(" 版本号机制")]),t._v(" "),s("ul",[s("li",[t._v("一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。")])]),t._v(" "),s("h3",{attrs:{id:"cas算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas算法"}},[t._v("#")]),t._v(" CAS算法")]),t._v(" "),s("ul",[s("li",[t._v("即compare and swap（比较与交换），是一种有名的"),s("strong",[t._v("无锁算法。无锁编程")])]),t._v(" "),s("li",[t._v("即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。")])]),t._v(" "),s("p",[s("strong",[t._v("CAS算法涉及到三个操作数")])]),t._v(" "),s("p",[t._v("1.需要读写的内存值 V")]),t._v(" "),s("p",[t._v("2.进行比较的值 A")]),t._v(" "),s("p",[t._v("3.拟写入的新值 B")]),t._v(" "),s("blockquote",[s("p",[t._v("当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。")])]),t._v(" "),s("h3",{attrs:{id:"乐观锁的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁的缺点"}},[t._v("#")]),t._v(" 乐观锁的缺点")]),t._v(" "),s("p",[t._v("1 ABA 问题,值相等的时候那CAS操作就会误认为它从来没有被修改过")]),t._v(" "),s("p",[t._v("2 循环时间长开销大")]),t._v(" "),s("p",[t._v("3 只能保证一个共享变量的原子操作")]),t._v(" "),s("h3",{attrs:{id:"cas与synchronized的使用情景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas与synchronized的使用情景"}},[t._v("#")]),t._v(" CAS与synchronized的使用情景")]),t._v(" "),s("blockquote",[s("p",[t._v("简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）")])]),t._v(" "),s("p",[s("strong",[t._v("对于资源竞争")])]),t._v(" "),s("blockquote",[s("p",[t._v("较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。")])]),t._v(" "),s("blockquote",[s("p",[t._v("争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("CAS无锁编程适用于乐观锁，读比较多")]),t._v(" "),s("p",[t._v("synchronized适用悲观锁，写比较多")])]),t._v(" "),s("h2",{attrs:{id:"synchronized-同步锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-同步锁"}},[t._v("#")]),t._v(" synchronized() 同步锁")]),t._v(" "),s("ul",[s("li",[t._v("锁 优点是能保证线程安全，解决高并发")]),t._v(" "),s("li",[t._v("缺点就是锁了就会花费这个执行过程的时间，")]),t._v(" "),s("li",[t._v("不同的锁是同时进行的")]),t._v(" "),s("li",[t._v("没加锁的方法是互相不干扰的")]),t._v(" "),s("li",[t._v("抛异常了java虚拟机也会自动帮我们释放锁")])]),t._v(" "),s("h3",{attrs:{id:"对象锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象锁"}},[t._v("#")]),t._v(" 对象锁")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("lzq1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第一种写法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("lzq2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第二种写法")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"类锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类锁"}},[t._v("#")]),t._v(" 类锁")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//第一种写法\npublic static synchronized void lzq(){}\n\n\n//第二种写法\npublic  void lzq(){\n    synchronized(sb.class){\n        \n    }\n}\n")])])]),s("h2",{attrs:{id:"死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/javaFrameWork/1601792496.jpg?v=1"),width:"210",alt:"img"}}),t._v(" "),s("h2",{attrs:{id:"lock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lock"}},[t._v("#")]),t._v(" lock")]),t._v(" "),s("p",[t._v("是一种更加灵活的锁，锁有很多种 碰到在继续整理吧")]),t._v(" "),s("h2",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),s("h3",{attrs:{id:"redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[t._v("#")]),t._v(" Redis")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/docs/redis/redis2.html#redis事务"}},[t._v("redis提供了乐观锁")])],1),t._v(" "),s("h3",{attrs:{id:"zookeeper"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[t._v("#")]),t._v(" Zookeeper")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/docs/javaFramework/zookeeper.html#理念"}},[t._v("Zookeeper")]),t._v("的顺序临时节点，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。")],1)])}),[],!1,null,null,null);a.default=e.exports}}]);